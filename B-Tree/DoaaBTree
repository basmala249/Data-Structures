#include <iostream>

using namespace std;

// Template class for BTreeNode
template <typename T, int order>
class BTreeNode {
public:
    T* keys; // Array to store keys of type T
    BTreeNode** children; // Array of pointers to child nodes
    bool isLeaf; // True if node is a leaf

    int currentKeys; // Current number of keys in the node

    BTreeNode(bool isLeaf);

    void insertNonFull(T key);
    void splitChild(int i, BTreeNode* child);
    void printLevel();
};

template <typename T, int order>
BTreeNode<T, order>::BTreeNode(bool isLeaf) {
    this->isLeaf = isLeaf;
    this->currentKeys = 0;
    keys = new T[order]; // Allocate array for keys
    children = new BTreeNode*[order + 1]; // Allocate array for children (maxKeys + 1 children)
}

// Template class for BTree
template <typename T, int order>
class BTree {
public:
    BTreeNode<T, order>* root; // Pointer to the root node

    BTree() {
        root = new BTreeNode<T, order>(true);
    }

    void insert(T key);
    void levelOrderTraverse();
};

template <typename T, int order>
void BTree<T, order>::levelOrderTraverse() {
    if (!root) return;

    // This array will hold the current level's nodes
    BTreeNode<T, order>* nodesAtCurrentLevel[100];  // Arbitrary size, you can increase if needed
    int currentLevelSize = 1;
    int currentIndex = 0;
    int level = 0; // Track the current level

    nodesAtCurrentLevel[0] = root;

    // Traverse level by level
    while (currentIndex < currentLevelSize) {
        int nodeCountAtCurrentLevel = currentLevelSize - currentIndex;

        // Process all nodes at the current level
        for (int i = 0; i < nodeCountAtCurrentLevel; ++i) {
            BTreeNode<T, order>* node = nodesAtCurrentLevel[currentIndex++];

            // Print the current level's indentation
            for (int indent = 0; indent < level; ++indent) {
                cout << "  ";  // Two spaces for each level of depth
            }

            // Print the keys of the current node
            for (int j = 0; j < node->currentKeys; ++j) {
                cout << node->keys[j];
                if (j != node->currentKeys - 1) cout << ",";
            }
            cout << "\n";

            // Add children to the array for the next level
            if (!node->isLeaf) {
                for (int i = 0; i <= node->currentKeys; ++i) {
                    nodesAtCurrentLevel[currentLevelSize++] = node->children[i];
                }
            }
        }

        level++; // Increase indentation level after each level of traversal
    }
}

// Definition for BTreeNode::insertNonFull() method
template <typename T, int order>
void BTreeNode<T, order>::insertNonFull(T key) {
    int i = currentKeys - 1;

    if (isLeaf) {
        while (i >= 0 && keys[i] > key) {
            keys[i + 1] = keys[i];
            i--;
        }
        keys[i + 1] = key;
        currentKeys++;
    } else {
        while (i >= 0 && keys[i] > key)
            i--;

        if (children[i + 1]->currentKeys == order) {
            splitChild(i + 1, children[i + 1]);

            if (keys[i + 1] < key)
                i++;
        }
        children[i + 1]->insertNonFull(key);
    }
}

// Definition for BTreeNode::splitChild() method
template <typename T, int order>
void BTreeNode<T, order>::splitChild(int i, BTreeNode* child) {
    int medianIndex = order / 2;

    BTreeNode* newChild = new BTreeNode<T, order>(child->isLeaf);
    newChild->currentKeys = order - medianIndex - 1;

    for (int j = 0; j < newChild->currentKeys; ++j) {
        newChild->keys[j] = child->keys[medianIndex + 1 + j];
    }

    if (!child->isLeaf) {
        for (int j = 0; j < newChild->currentKeys + 1; ++j) {
            newChild->children[j] = child->children[medianIndex + 1 + j];
        }
    }

    child->currentKeys = medianIndex;

    for (int j = currentKeys; j > i; --j) {
        children[j + 1] = children[j];
    }

    children[i + 1] = newChild;

    for (int j = currentKeys - 1; j >= i; --j) {
        keys[j + 1] = keys[j];
    }

    keys[i] = child->keys[medianIndex];
    currentKeys++;
}

// Definition for BTree::insert() method
template <typename T, int order>
void BTree<T, order>::insert(T key) {
    if (root->currentKeys == order) {
        BTreeNode<T, order>* newRoot = new BTreeNode<T, order>(false);
        newRoot->children[0] = root;
        newRoot->splitChild(0, root);

        int i = 0;
        if (newRoot->keys[0] < key)
            i++;
        newRoot->children[i]->insertNonFull(key);

        root = newRoot;
    } else {
        root->insertNonFull(key);
    }
}

// Main function
int main() {
    // Create BTree with integer keys and degree 3
    BTree<char, 5> t;
    t.insert('G');
    t.insert('I');
    t.insert('B');
    t.insert('J');
    t.insert('C');
    t.insert('A');
    t.insert('K');
    t.insert('E');
    t.insert('D');
    t.insert('S');
    t.insert('T');
    t.insert('R');
    t.insert('L');
    t.insert('F');
    t.insert('H');
    t.insert('M');
    t.insert('N');
    t.insert('P');
    t.insert('Q');


    t.levelOrderTraverse();

    return 0;
}
